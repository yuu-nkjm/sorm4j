package org.nkjmlab.sorm4j.mapping;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.BiConsumer;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import org.nkjmlab.sorm4j.InsertResult;
import org.nkjmlab.sorm4j.OrmException;
import org.nkjmlab.sorm4j.config.BatchConfig;
import org.nkjmlab.sorm4j.config.ColumnFieldMapper;
import org.nkjmlab.sorm4j.config.JavaToSqlDataConverter;
import org.nkjmlab.sorm4j.config.SqlToJavaDataConverter;
import org.nkjmlab.sorm4j.util.ArrayUtils;
import org.nkjmlab.sorm4j.util.DebugPoint;
import org.nkjmlab.sorm4j.util.DebugPointFactory;
import org.nkjmlab.sorm4j.util.StringUtils;
import org.nkjmlab.sorm4j.util.Try;

/**
 * Holds mapping data from a given class and a table
 */
public final class TableMapping<T> extends Mapping<T> {

  private static final org.slf4j.Logger log = org.nkjmlab.sorm4j.util.LoggerFactory.getLogger();

  private final JavaToSqlDataConverter javaToSqlConverter;

  private final String tableName;
  private final List<String> primaryKeys;
  private final List<String> autoGeneratedColumns;
  private final String[] autoGeneratedColumnsArray;
  private final List<String> notAutoGeneratedColumns;
  private final List<String> columnsForUpdate;
  private final List<String> allColumns;

  private final SqlFromTableMapping sql;

  private final Batcher batcher;


  private TableMapping(SqlToJavaDataConverter sqlToJavaConverter,
      JavaToSqlDataConverter javaToSqlConverter, Class<T> objectClass, String tableName,
      List<Column> columns, ColumnFieldMapper fieldMapper, BatchConfig batchConf,
      Connection connection) {
    super(sqlToJavaConverter, objectClass, columns, fieldMapper);
    try {
      this.javaToSqlConverter = javaToSqlConverter;

      this.batcher = new Batcher(batchConf);
      DatabaseMetaData metaData = connection.getMetaData();
      this.tableName = tableName;



      // all primary keys (from db)
      this.primaryKeys = fieldMapper.getPrimaryKeys(metaData, tableName);


      List<Column> _autoGeneratedColumns = fieldMapper.getAutoGeneratedColumns(metaData, tableName);

      this.autoGeneratedColumns =
          _autoGeneratedColumns.stream().map(c -> c.getName()).collect(Collectors.toList());
      this.autoGeneratedColumnsArray = autoGeneratedColumns.toArray(String[]::new);

      this.notAutoGeneratedColumns =
          columns.stream().filter(col -> !_autoGeneratedColumns.contains(col)).map(c -> c.getName())
              .collect(Collectors.toList());

      List<String> notPrimaryKeys = createNoPrimaryKeys(primaryKeys, columns).stream()
          .map(c -> c.getName()).collect(Collectors.toList());
      this.columnsForUpdate = new ArrayList<>(notPrimaryKeys);
      columnsForUpdate.addAll(primaryKeys);

      this.allColumns = columns.stream().map(c -> c.getName()).collect(Collectors.toList());
      // assemble sql blocks to be used by crud sql statements
      this.sql = new SqlFromTableMapping(tableName, primaryKeys, notPrimaryKeys,
          autoGeneratedColumns, notAutoGeneratedColumns, allColumns);

      if (!StringUtils.equalsSetIgnoreCase(allColumns, columnToAccessorMap.keySet())) {
        throw new OrmException(StringUtils.format(
            "{} does not match any field. Table [{}] contains Columns {} but [{}] contains Fields {}.",
            allColumns.stream().filter(e -> !columnToAccessorMap.keySet().contains(e)).sorted()
                .collect(Collectors.toList()),
            tableName, columns.stream().sorted().collect(Collectors.toList()),
            objectClass.getName(),
            columnToAccessorMap.keySet().stream().sorted().collect(Collectors.toList())));
        // .orElseThrow(() -> new RuntimeException(MessageUtils.format(
        // "Column [{}] does not match any field of [{}]. The field names of the class are {}.",
        // column, objectClass.getName(), fields.keySet())))
      }

    } catch (SQLException e) {
      throw new OrmException(e);
    }
  }



  public static final <T> TableMapping<T> createMapping(SqlToJavaDataConverter sqlToJavaConverter,
      JavaToSqlDataConverter javaToSqlConverter, Class<T> objectClass, String tableName,
      ColumnFieldMapper fieldMapper, BatchConfig batchConfig, Connection connection) {
    try {
      DatabaseMetaData metaData = connection.getMetaData();
      return new TableMapping<>(sqlToJavaConverter, javaToSqlConverter, objectClass, tableName,
          fieldMapper.getColumns(metaData, tableName), fieldMapper, batchConfig, connection);
    } catch (SQLException e) {
      throw new OrmException(e);
    }
  }


  private static List<Column> createNoPrimaryKeys(List<String> primaryKeys, List<Column> columns) {
    return columns.stream().filter(col -> !primaryKeys.contains(col.getName()))
        .collect(Collectors.toList());
  }



  private static final Map<String, Class<?>> setterParamTypeMap = new ConcurrentHashMap<>();

  private Class<?> getSetterParamType(String column) {
    return setterParamTypeMap.computeIfAbsent(column,
        k -> columnToAccessorMap.get(column).getSetterParameterType());
  }


  public String getTableName() {
    return tableName;
  }

  public List<String> getAllColumns() {
    return allColumns;
  }

  public List<String> notAutoGeneratedColumns() {
    return notAutoGeneratedColumns;
  }


  public List<String> getPrimaryKeys() {
    return primaryKeys;
  }

  public SqlFromTableMapping getSql() {
    return sql;
  }

  private Object[] getInsertParameters(T object) {
    return getParameters(object, notAutoGeneratedColumns);
  }

  private Object[] getMergeParameters(T object) {
    return getParameters(object, notAutoGeneratedColumns);
  }

  private Object[] getParametersWithoutAutoGeneratedColumns(T object) {
    return getParameters(object, notAutoGeneratedColumns);
  }


  private Object[] getDeleteParameters(T object) {
    return getParameters(object, getPrimaryKeys());
  }

  private Object[] getUpdateParameters(T object) {
    return getParameters(object, columnsForUpdate);
  }

  public Object[] getParameters(Object object, List<String> columns) {
    return columns.stream().map(columnName -> getValue(object, columnName)).toArray(Object[]::new);
  }

  private static PreparedStatement getPreparedStatement(Connection connection, String sql) {
    try {
      return connection.prepareStatement(sql);
    } catch (SQLException e) {
      throw new OrmException(
          "Error creating prepared statement for sql [" + sql + "] : " + e.getMessage(), e);
    }
  }

  private static PreparedStatement getPreparedStatement(Connection connection, String sql,
      String... autoGeneratedKeys) {
    try {
      return (autoGeneratedKeys == null || autoGeneratedKeys.length == 0)
          ? connection.prepareStatement(sql)
          : connection.prepareStatement(sql, autoGeneratedKeys);
    } catch (SQLException e) {
      throw new OrmException(
          "Error creating prepared statement for sql [" + sql + "] with autoGeneratedKeys "
              + Arrays.toString(autoGeneratedKeys) + ": " + e.getMessage(),
          e);
    }
  }

  private List<Object> setAutoGeneratedKeys(PreparedStatement stmt, T object) {
    try (ResultSet resultSet = stmt.getGeneratedKeys()) {
      ResultSetMetaData metaData = resultSet.getMetaData();
      List<Object> ret = new ArrayList<>();
      while (resultSet.next()) {
        String columnName = metaData.getColumnName(1);
        // Don't user type from metadata (metaData.getColumnType(1)) because object class of
        // container is prior.
        Class<?> type = getSetterParamType(columnName);
        final Object value = sqlToJavaConverter.getValueByClass(resultSet, 1, type);
        setValue(object, columnName, value);
        ret.add(value);
      }
      return ret;
    } catch (SQLException e) {
      throw new OrmException(e);
    }

  }


  @SafeVarargs
  private final void setPrameters(PreparedStatement stmt, T... objects) {
    Object[] parameters = Arrays.stream(objects)
        .flatMap(obj -> Arrays.stream(getParametersWithoutAutoGeneratedColumns(obj)))
        .toArray(Object[]::new);
    try {
      javaToSqlConverter.setParameters(stmt, parameters);
    } catch (SQLException e) {
      throw new OrmException(e);
    }
  }



  private int executeUpdate(Connection connection, String sql, final Object... parameters) {
    try (PreparedStatement stmt = getPreparedStatement(connection, sql)) {
      javaToSqlConverter.setParameters(stmt, parameters);
      final Optional<DebugPoint> dp =
          DebugPointFactory.createDebugPoint(DebugPointFactory.Name.EXECUTE_UPDATE);
      int ret = stmt.executeUpdate();
      dp.ifPresent(
          sw -> log.debug("{} ExecuteUpdate for one object of [{}] to [{}] Table at [{}] =? [{}]",
              sw.getFormattedNameAndElapsedTime(), objectClass.getSimpleName(), getTableName(),
              Try.getForceOrNull(() -> connection.getMetaData().getURL()), sql));
      return ret;
    } catch (SQLException e) {
      throw new OrmException(e);
    }
  }

  /**
   * Updates an object in the database. The object will be identified using its mapped table's
   * primary key. If no primary keys are defined in the mapped table, a {@link RuntimeException}
   * will be thrown.
   *
   * @since 1.0
   */


  public int update(Connection connection, T object) {
    if (getPrimaryKeys().size() == 0) {
      throw new OrmException("Table " + getTableName() + " doesn't have a primary key");
    }
    return executeUpdate(connection, getSql().getUpdateSql(), getUpdateParameters(object));
  }

  /**
   * Updates a batch of objects in the database. The objects will be identified using their mapped
   * table's primary keys. If no primary keys are defined in the mapped table, a
   * {@link RuntimeException} will be thrown.
   *
   * @since 1.0
   */

  public int[] update(Connection connection, T[] objects) {
    return execIfValidObjects(connection, objects, nonNullObjects -> {
      return batcher.batch(connection, sql.getUpdateSql(), obj -> getUpdateParameters(obj),
          nonNullObjects);
    });
  }

  // ---------- delete ----------

  /**
   * Deletes an object in the database. The object will be identified using its mapped table's
   * primary key. If no primary keys are defined in the mapped table, a RuntimeException will be
   * thrown.
   *
   * @since 1.0
   */


  public int delete(Connection connection, T object) {
    if (getPrimaryKeys().size() == 0) {
      throw new OrmException("Table " + getTableName() + " doesn't have a primary key");
    }
    return executeUpdate(connection, getSql().getDeleteSql(), getDeleteParameters(object));
  }

  /**
   * Updates a batch of objects in the database. The objects will be identified using their matched
   * table's primary keys. If no primary keys are defined in a given object, a RuntimeException will
   * be thrown.
   *
   * @since 1.0
   */

  public int[] delete(Connection connection, @SuppressWarnings("unchecked") T... objects) {
    return execIfValidObjects(connection, objects, nonNullObjects -> {
      return batcher.batch(connection, sql.getDeleteSql(), obj -> getDeleteParameters(obj),
          nonNullObjects);
    });
  }


  private int[] execIfValidObjects(Connection con, T[] objects, Function<T[], int[]> exec) {
    if (objects == null || objects.length == 0) {
      return new int[0];
    }
    Optional<DebugPoint> dp =
        DebugPointFactory.createDebugPoint(DebugPointFactory.Name.EXECUTE_BATCH);
    @SuppressWarnings("unchecked")
    T[] nonNullObjects =
        (T[]) Arrays.stream(objects).filter(Objects::nonNull).toArray(Object[]::new);
    int[] result = exec.apply(nonNullObjects);
    dp.ifPresent(sw -> log.debug("{} [{}] objects (req=[{}]) of [{}] are wrote into [{}]  at [{}]",
        sw.getFormattedNameAndElapsedTime(), IntStream.of(result).sum(), objects.length,
        TableMapping.super.objectClass.getSimpleName(), getTableName(),
        Try.getForceOrNull(() -> con.getMetaData().getURL())));
    return result;


  }

  public int insert(Connection connection, T object) {
    return executeUpdate(connection, sql.getInsertSql(), getInsertParameters(object));
  }

  public int merge(Connection connection, T object) {
    return executeUpdate(connection, sql.getInsertSql(), getMergeParameters(object));
  }



  public InsertResult<T> insertAndGetResult(Connection connection, T object) {
    try (PreparedStatement stmt =
        getPreparedStatement(connection, sql.getInsertSql(), autoGeneratedColumnsArray)) {
      javaToSqlConverter.setParameters(stmt, getInsertParameters(object));
      int rowsModified = stmt.executeUpdate();
      List<Object> keys = setAutoGeneratedKeys(stmt, object);
      return new InsertResult<T>(new int[] {rowsModified}, object, keys);
    } catch (SQLException e) {
      throw new OrmException(e);
    }
  }


  // ---------- batch ----------

  public int[] insertBatchEach(Connection con, T[] objects) {
    return batcher.batchEach(con, obj -> insert(con, obj), objects);
  }

  public int[] insertSimpleBatch(Connection con, T[] objects) {
    return execIfValidObjects(con, objects, nonNullObjects -> {
      return batcher.batch(con, sql.getInsertSql(), obj -> getInsertParameters(obj),
          nonNullObjects);
    });
  }

  public int[] insertMultiRow(Connection con, T[] objects) {
    return execIfValidObjects(con, objects, nonNullObjects -> {
      return batcher.multiRow(con, num -> getMultirowInsertPreparedStatement(con, num),
          (stmt, objs) -> setPrameters(stmt, objs), nonNullObjects);
    });
  }

  public int[] insertMultiRowBatch(Connection con, T[] objects) {
    return execIfValidObjects(con, objects, nonNullObjects -> {
      return batcher.batchMultiRow(con, num -> getMultirowInsertPreparedStatement(con, num),
          (stmt, objs) -> setPrameters(stmt, objs), nonNullObjects);
    });
  }


  @SafeVarargs
  public final int[] insert(Connection con, T... objects) {
    return execIfValidObjects(con, objects, nonNullObjects -> {
      return batcher.multiRow(con, num -> getMultirowInsertPreparedStatement(con, num),
          (stmt, objs) -> setPrameters(stmt, objs), nonNullObjects);
    });
  }

  private PreparedStatement getMultirowInsertPreparedStatement(Connection con, int num) {
    PreparedStatement stmt = getPreparedStatement(con, sql.getMultirowInsertSql(num));
    return stmt;
  }



  @SafeVarargs
  public final InsertResult<T> insertAndGetResult(Connection con, T... objects) {
    if (objects == null || objects.length == 0) {
      return InsertResult.empty();
    }

    @SuppressWarnings("unchecked")
    T[] objsWithoutLast =
        (T[]) Arrays.asList(objects).subList(0, objects.length - 1).toArray(Object[]::new);
    T last = objects[objects.length - 1];
    int[] resultWithoutLast = insert(con, objsWithoutLast);

    InsertResult<T> insertResult = insertAndGetResult(con, last);
    int[] result = ArrayUtils.add(resultWithoutLast, insertResult.getRowsModified()[0]);

    return new InsertResult<T>(result, insertResult.getObject(),
        insertResult.getAutoGeneratedKeys());
  }

  public int[] batch(Connection con, String sql, Function<T, Object[]> parameterCreator,
      T[] objects) {
    return this.batcher.batch(con, sql, parameterCreator, objects);
  }



  @SuppressWarnings("unchecked")
  public int[] merge(Connection con, T... objects) {
    int[] result = batcher.multiRow(con, num -> getMultirowMergePreparedStatement(con, num),
        (stmt, objs) -> setPrameters(stmt, objs), objects);
    return result;
  }

  private PreparedStatement getMultirowMergePreparedStatement(Connection con, int num) {
    PreparedStatement stmt = getPreparedStatement(con, sql.getMultirowMergeSql(num));
    return stmt;
  }



  private final class Batcher {
    private final int multiRowSize;
    private final int batchSize;
    private final int batchSizeWithMultiRow;

    public Batcher(BatchConfig batchConf) {
      this.multiRowSize = batchConf.getMultiRowSize();
      this.batchSize = batchConf.getBatchSize();
      this.batchSizeWithMultiRow = batchConf.getBatchSizeWithMultiRow();
    }

    private final int[] multiRow(Connection con,
        Function<Integer, PreparedStatement> multiRowStatementCreator,
        BiConsumer<PreparedStatement, T[]> parametersSetter, T[] objects) {
      final List<T[]> objsPartitions = ArrayUtils.split(multiRowSize, objects);
      final int[] result = new int[objsPartitions.size()];
      final boolean origAutoCommit = getAutoCommit(con);

      try {
        setAutoCommit(con, false);
        try (PreparedStatement stmt = multiRowStatementCreator.apply(multiRowSize)) {
          for (int partitionNum = 0; partitionNum < objsPartitions.size() - 1; partitionNum++) {
            T[] objectsInOnePartition = objsPartitions.get(partitionNum);
            parametersSetter.accept(stmt, objectsInOnePartition);
            result[partitionNum] = stmt.executeUpdate();
          }
        }
        int lastPartition = objsPartitions.size() - 1;
        T[] objectsInLastPartition = objsPartitions.get(lastPartition);
        try (PreparedStatement stmt =
            multiRowStatementCreator.apply(objectsInLastPartition.length)) {
          parametersSetter.accept(stmt, objectsInLastPartition);
          result[lastPartition] = stmt.executeUpdate();
          return result;
        }
      } catch (SQLException e) {
        rollbackIfRequired(con, origAutoCommit);
        throw new OrmException(e);
      } finally {
        commitIfRequired(con, origAutoCommit);
        setAutoCommit(con, origAutoCommit);
      }
    }

    /**
     * addBatch with multi-row. In H2 addBatch is not effictive.
     *
     * @param sqlCreator
     * @param parameterCreator
     * @param objects
     * @return
     */
    private final int[] batchMultiRow(Connection con,
        Function<Integer, PreparedStatement> multiRowStatementCreator,
        BiConsumer<PreparedStatement, T[]> parametersSetter, T[] objects) {

      final List<T[]> objsPartitions = ArrayUtils.split(multiRowSize, objects);
      final int[] result = new int[objsPartitions.size()];
      final boolean origAutoCommit = getAutoCommit(con);

      try {
        setAutoCommit(con, false);
        try (PreparedStatement stmt = multiRowStatementCreator.apply(multiRowSize)) {
          final BatchHelper helper = new BatchHelper(batchSizeWithMultiRow, stmt);
          for (int partitionNum = 0; partitionNum < objsPartitions.size() - 1; partitionNum++) {
            T[] objectsInOnePartition = objsPartitions.get(partitionNum);
            parametersSetter.accept(stmt, objectsInOnePartition);
            helper.addBatchAndExecuteIfReachedThreshold();
          }
          int[] firstResult = helper.finish();
          System.arraycopy(firstResult, 0, result, 0, firstResult.length);
        }
        // Recreate PreparedStatement because last partition is different size probably.
        int lastPartition = objsPartitions.size() - 1;
        T[] objectsInLastPartition = objsPartitions.get(lastPartition);
        try (PreparedStatement lastStmt =
            multiRowStatementCreator.apply(objectsInLastPartition.length)) {
          parametersSetter.accept(lastStmt, objectsInLastPartition);
          result[lastPartition] = lastStmt.executeUpdate();
          return result;
        }
      } catch (Exception e) {
        rollbackIfRequired(con, origAutoCommit);
        throw new OrmException(e);
      } finally {
        commitIfRequired(con, origAutoCommit);
        setAutoCommit(con, origAutoCommit);
      }

    }


    private final int[] batchEach(Connection con, Function<T, Integer> parameterCreator,
        final T[] objects) {
      final Optional<DebugPoint> dp =
          DebugPointFactory.createDebugPoint(DebugPointFactory.Name.EXECUTE_BATCH);
      final int[] result = new int[objects.length];
      final boolean origAutoCommit = getAutoCommit(con);

      try {
        setAutoCommit(con, false);
        for (int i = 0; i < objects.length; i++) {
          result[i] = parameterCreator.apply(objects[i]);
        }
        return result;
      } catch (Exception e) {
        rollbackIfRequired(con, origAutoCommit);
        throw new OrmException(e);
      } finally {
        setAutoCommit(con, origAutoCommit);
        commitIfRequired(con, origAutoCommit);
        dp.ifPresent(
            sw -> log.debug("{} [{}] objects (req=[{}]) of [{}] are wrote into [{}] to [{}]",
                sw.getFormattedNameAndElapsedTime(), IntStream.of(result).sum(), objects.length,
                TableMapping.super.objectClass.getSimpleName(), getTableName(),
                Try.getForceOrNull(() -> con.getMetaData().getURL())));
      }
    }


    public int[] batch(Connection con, String sql, Function<T, Object[]> parameterCreator,
        T[] objects) {

      int[] result = new int[0];
      boolean origAutoCommit = getAutoCommit(con);

      try (PreparedStatement stmt = getPreparedStatement(con, sql)) {
        setAutoCommit(con, false);
        final BatchHelper batchHelper = new BatchHelper(batchSize, stmt);
        for (int i = 0; i < objects.length; i++) {
          T obj = objects[i];
          javaToSqlConverter.setParameters(stmt, parameterCreator.apply(obj));
          batchHelper.addBatchAndExecuteIfReachedThreshold();
        }
        result = batchHelper.finish();
        return result;
      } catch (Exception e) {
        rollbackIfRequired(con, origAutoCommit);
        throw new OrmException(e);
      } finally {
        commitIfRequired(con, origAutoCommit);
        setAutoCommit(con, origAutoCommit);
      }
    }

    private final class BatchHelper {

      private final int batchSize;
      private final PreparedStatement stmt;
      private int counter;
      private final List<int[]> result = new ArrayList<>();

      public BatchHelper(int batchSize, PreparedStatement stmt) {
        this.batchSize = batchSize;
        this.stmt = stmt;
      }

      public void addBatchAndExecuteIfReachedThreshold() {
        addBatch();
        if (counter + 1 % batchSize == 0) {
          executeBatch();
        }
      }

      private void addBatch() {
        try {
          stmt.addBatch();
          counter++;
        } catch (SQLException e) {
          throw new OrmException(e);
        }
      }

      public int[] finish() {
        executeBatch();
        return result.stream().flatMapToInt(e -> IntStream.of(e)).toArray();
      }

      private void executeBatch() {
        try {
          if (counter == 0) {
            return;
          }
          int[] tmp = stmt.executeBatch();
          result.add(tmp);
          counter = 0;
        } catch (SQLException e) {
          throw new OrmException(e);
        }
      }
    }

    private void setAutoCommit(Connection connection, boolean autoCommit) {
      Try.runOrThrow(() -> connection.setAutoCommit(autoCommit), OrmException::new);
    }

    private void commitIfRequired(Connection connection, boolean origAutoCommit) {
      if (origAutoCommit) {
        Try.runOrThrow(() -> connection.commit(), OrmException::new);
      }
    }


    private void rollbackIfRequired(Connection connection, boolean origAutoCommit) {
      if (!origAutoCommit) {
        Try.runOrThrow(() -> connection.rollback(), OrmException::new);
      }
    }

    private boolean getAutoCommit(Connection connection) {
      return Try.supplyOrThrow(() -> connection.getAutoCommit(), OrmException::new).get();
    }

  }

  @Override
  public String toString() {
    return "TableMapping [" + super.toString() + "]";
  }

  public String getFormattedString() {
    return "TABLE [" + tableName + "] is mapped to [" + objectClass.getSimpleName() + "] class. "
        + "PRIMARY KEY is " + primaryKeys + System.lineSeparator()
        + super.getColumnToAccessorString();
  }



}
